package io.github.epi155.recfm.java;

import io.github.epi155.recfm.exec.GenerateArgs;
import io.github.epi155.recfm.exec.LanguageContext;
import io.github.epi155.recfm.lang.AccessField;
import io.github.epi155.recfm.lang.InitializeField;
import io.github.epi155.recfm.lang.ValidateField;
import io.github.epi155.recfm.type.*;
import lombok.extern.slf4j.Slf4j;
import lombok.val;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.CharBuffer;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.OptionalInt;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.IntFunction;
import java.util.stream.Collectors;

@Slf4j
public class ContextJava extends LanguageContext implements IndentAble {
    private static final String SYSTEM_PACKAGE = "io.github.epi155.recfm.java";


    public static String rpad(String s, int t, char pad) {
        final int len = s.length();
        if (len > t) return s.substring(0, t);
        if (len == t) return s;
        return s + CharBuffer.allocate(t - len).toString().replace('\0', pad);
    }

    static void writeCopyright(PrintWriter pw) {
        String now = ZonedDateTime.now(ZoneOffset.UTC).format(DateTimeFormatter.ISO_INSTANT);
        pw.println("/*");
        pw.printf(" * Generated by recfm-maven-plugin %s at %s%n", VERSION, now);
        pw.println(" */");
    }

    @Override
    public void copyTemplate(ClassLoader classLoader, String utilDirectory, String utilPackage) {
        Templates.copy(classLoader, utilDirectory, utilPackage);
    }

    protected void generateClass(ClassDefine struct, String cwd, String wrtPackage, GenerateArgs ga, Defaults defaults) {
        log.info("- Prepare class {} ...", struct.getName());
        val classFile = new File(cwd + File.separator + struct.getName() + ".java");

        checkForVoid(struct);
        val utilPackage = (ga.utilPackage == null) ? SYSTEM_PACKAGE : ga.utilPackage;

        boolean checkSuccesful = struct.noBadName();
        checkSuccesful &= struct.noDuplicateName();
        checkSuccesful &= struct.noHole();
        checkSuccesful &= struct.noOverlap();
        if (checkSuccesful) {
            try (PrintWriter pw = new PrintWriter(classFile)) {
                writePackage(pw, wrtPackage);
                writeImport(pw);
                if (!wrtPackage.equals(utilPackage))
                    writeImport(pw, utilPackage);
                generateClassCode(pw, struct, ga, defaults, n -> String.format("%d", n - 1));
                log.info("  * Created.");
            } catch (IOException e) {
                throw new ClassDefineException(e);
            }
        } else {
            throw new ClassDefineException("Class <" + struct.getName() + "> bad defined");
        }
    }

    private void generateClassCode(PrintWriter pw, ClassDefine struct, GenerateArgs ga, Defaults defaults, IntFunction<String> pos) {
        writeBeginClass(pw, struct);
        writeConstant(pw, struct, 0, false);
        pw.println();
        struct.getFields().forEach(it -> {
            if (it instanceof SelfCheck) ((SelfCheck) it).selfCheck();
            if (it instanceof FieldGroup) generateGroupCode((FieldGroup) it, pw, 4, ga, defaults, pos);
        });
        val access = new AccessFieldJava(pw, pos);
        writeCtorVoid(pw, struct.getName());
        writeCtorParm(pw, struct);
        writeInitializer(pw, struct, defaults);
        writeValidator(pw, struct, defaults);
        struct.getFields().forEach(it -> {
            if (it instanceof SettableField) access.createMethods((SettableField) it, 0, ga);
        });
        writeDump(pw, struct.getFields());
        writeEndClass(pw, 0);
    }

    private void writeDump(PrintWriter pw, List<NakedField> fields) {
        List<DumpPicure> lst = new ArrayList<>();
        for (NakedField field : fields) {
            if (field instanceof FieldAbc) {
                FieldAbc fa = (FieldAbc) field;
                if (fa.isRedefines()) continue;
                lst.add(new DumpPicure(fa.getName(), fa.getOffset(), fa.getLength(), "X"));
            } else if (field instanceof FieldNum) {
                FieldNum fn = (FieldNum) field;
                if (fn.isRedefines()) continue;
                lst.add(new DumpPicure(fn.getName(), fn.getOffset(), fn.getLength(), "9"));
            } else if (field instanceof FieldConstant) {
                lst.add(new DumpPicure("<Constant>", field.getOffset(), field.getLength(), "X"));
            } else if (field instanceof FieldOccurs) {
                FieldOccurs fo = (FieldOccurs) field;
                if (fo.isRedefines()) continue;
                lst.addAll(occursDump(fo.getName(), fo.getTimes(), fo.getLength(), fo.getFields(), 0));
            } else if (field instanceof FieldGroup) {
                FieldGroup fg = (FieldGroup) field;
                if (fg.isRedefines()) continue;
                lst.addAll(groupDump(fg.getName(), fg.getFields(), 0));
            }
        }
        List<DumpAware> l2 = lst.stream().map(DumpPicure::normalize).collect(Collectors.toList());
        OptionalInt w = l2.stream().mapToInt(it -> it.name.length()).max();
        w.ifPresent(mx -> {
            List<DumpAware> l3 = l2.stream().map(it -> new DumpAware(rpad(it.name, mx + 3, '.'), it.offset, it.length)).collect(Collectors.toList());
            pw.printf("    @Override%n");
            pw.printf("    public String toString() {%n");
            pw.printf("        StringBuilder sb = new StringBuilder();%n");
            l3.forEach(it -> it.dump(pw));
            pw.printf("        return sb.toString();%n");
            closeBrace(pw);
        });

    }

    private Collection<? extends DumpPicure> occursDump(String prefix, int times, int size, List<NakedField> fields, int initBias) {
        List<DumpPicure> lst = new ArrayList<>();

        for (int k = 1, bias = initBias; k <= times; k++, bias += size) {
            String px = prefix + "[" + k + "].";
            for (NakedField field : fields) {
                if (field instanceof FieldAbc) {
                    FieldAbc fa = (FieldAbc) field;
                    if (fa.isRedefines()) continue;
                    lst.add(new DumpPicure(px + fa.getName(), bias + fa.getOffset(), fa.getLength(), "X"));
                } else if (field instanceof FieldNum) {
                    FieldNum fn = (FieldNum) field;
                    if (fn.isRedefines()) continue;
                    lst.add(new DumpPicure(px + fn.getName(), bias + fn.getOffset(), fn.getLength(), "9"));
                } else if (field instanceof FieldConstant) {
                    lst.add(new DumpPicure("<Constant>", bias + field.getOffset(), field.getLength(), "X"));
                } else if (field instanceof FieldOccurs) {
                    FieldOccurs fo = (FieldOccurs) field;
                    if (fo.isRedefines()) continue;
                    lst.addAll(occursDump(px + fo.getName(), fo.getTimes(), fo.getLength(), fo.getFields(), bias));
                } else if (field instanceof FieldGroup) {
                    FieldGroup fg = (FieldGroup) field;
                    if (fg.isRedefines()) continue;
                    lst.addAll(groupDump(px + fg.getName(), fg.getFields(), bias));
                }
            }
        }
        return lst;
    }

    private Collection<? extends DumpPicure> groupDump(String prefix, List<NakedField> fields, int bias) {
        List<DumpPicure> lst = new ArrayList<>();
        for (NakedField field : fields) {
            if (field instanceof FieldAbc) {
                FieldAbc fa = (FieldAbc) field;
                if (fa.isRedefines()) continue;
                lst.add(new DumpPicure(prefix + "." + fa.getName(), bias + fa.getOffset(), fa.getLength(), "X"));
            } else if (field instanceof FieldNum) {
                FieldNum fn = (FieldNum) field;
                if (fn.isRedefines()) continue;
                lst.add(new DumpPicure(prefix + "." + fn.getName(), bias + fn.getOffset(), fn.getLength(), "9"));
            } else if (field instanceof FieldConstant) {
                lst.add(new DumpPicure("<Constant>", bias + field.getOffset(), field.getLength(), "X"));
            } else if (field instanceof FieldOccurs) {
                FieldOccurs fo = (FieldOccurs) field;
                if (fo.isRedefines()) continue;
                lst.addAll(occursDump(prefix + "." + fo.getName(), fo.getTimes(), fo.getLength(), fo.getFields(), bias));
            } else if (field instanceof FieldGroup) {
                FieldGroup fg = (FieldGroup) field;
                if (fg.isRedefines()) continue;
                lst.addAll(groupDump(prefix + "." + fg.getName(), fg.getFields(), bias));
            }
        }
        return lst;
    }

    private void generateGroupCode(FieldGroup fld, PrintWriter pw, int indent, GenerateArgs ga, Defaults defaults, IntFunction<String> pos) {
        AccessField access;
        if (fld instanceof FieldOccurs) {
            writeBeginClassOccurs(pw, (FieldOccurs) fld, indent);
            access = accessField(pw, n -> String.format("%d+shift", n - 1));
        } else {
            writeBeginClassGroup(pw, fld.getName(), indent);
            access = accessField(pw, pos);
        }
        fld.getFields().forEach(it -> {
            if (it instanceof SelfCheck) ((SelfCheck) it).selfCheck();
            if (it instanceof FieldGroup) generateGroupCode((FieldGroup) it, pw, indent + 4, ga, defaults, pos);
        });
        fld.getFields().forEach(it -> {
            if (it instanceof SettableField) access.createMethods((SettableField) it, indent, ga);
        });
        writeEndClass(pw, indent);
    }

    @Override
    protected AccessField accessField(PrintWriter pw, IntFunction<String> pos) {
        return new AccessFieldJava(pw, pos);
    }

    private void writeBeginClassOccurs(PrintWriter pw, FieldOccurs fld, int indent) {
        String capName = capitalize(fld.getName());
        indent(pw, indent);
        pw.printf("private final %s[] %s = new %1$s[] {%n", capName, fld.getName());
        for (int k = 0, shift = 0; k < fld.getTimes(); k++, shift += fld.getLength()) {
            indent(pw, indent);
            pw.printf("    this.new %s(%d),%n", capName, shift);
        }
        indent(pw, indent);
        pw.printf("};%n");
        indent(pw, indent);
        pw.printf("public %s %s(int k) { return this.%2$s[k-1]; }%n", capName, fld.getName());
        indent(pw, indent);
        pw.printf("public class %s {%n", capName);

        indent(pw, indent);
        pw.printf("    private final int shift;%n");
        indent(pw, indent);
        pw.printf("    private %s(int shift) { this.shift = shift; }%n", capName);
    }

    private void writeBeginClassGroup(PrintWriter pw, String name, int indent) {
        String capName = capitalize(name);
        indent(pw, indent);
        pw.printf("private final %s %s = this.new %1$s();%n", capName, name);
        indent(pw, indent);
        pw.printf("public %s %s() { return this.%2$s; }%n", capName, name);
        indent(pw, indent);
        pw.printf("public class %s {%n", capName);
    }

    private void writeEndClass(PrintWriter pw, int indent) {
        indent(pw, indent);
        pw.write("}");
        pw.println();
    }

    private void writeValidator(PrintWriter pw, ClassDefine struct, Defaults defaults) {
        int padWidth = struct.evalPadWidth(6);
        val validator = validateField(pw, struct.getName(), defaults);
        pw.printf("    @Override%n");
        pw.printf("    protected boolean validateFields(FieldValidateHandler handler) {%n");
        AtomicBoolean firstCheck = new AtomicBoolean(true);
        for (NakedField fld : struct.getFields()) {
            validator.validate(fld, padWidth, 1, firstCheck);
        }
        if (firstCheck.get()) {
            pw.printf("        return false;%n");
        } else {
            pw.printf("        return error;%n");
        }
        closeBrace(pw);

        pw.printf("    @Override%n");
        pw.printf("    protected boolean auditFields(FieldValidateHandler handler) {%n");
        AtomicBoolean firstAudit = new AtomicBoolean(true);
        for (NakedField fld : struct.getFields()) {
            if (fld instanceof CheckAware && ((CheckAware) fld).isAudit()) {
                validator.validate(fld, padWidth, 1, firstAudit);
            }
        }
        if (firstAudit.get()) {
            pw.printf("        return false;%n");
        } else {
            pw.printf("        return error;%n");
        }
        closeBrace(pw);
    }

    @Override
    protected ValidateField validateField(PrintWriter pw, String name, Defaults defaults) {
        return new ValidateFieldJava(pw, name, defaults);
    }

    private void writeInitializer(PrintWriter pw, ClassDefine struct, Defaults defaults) {
        pw.printf("    protected void initialize() {%n");
        val initializer = initializeField(pw, struct, defaults);
        struct.getFields().forEach(it -> initializer.field(it, 1));
        closeBrace(pw);
    }

    protected InitializeField initializeField(PrintWriter pw, ClassDefine struct, Defaults defaults) {
        return new InitializeFieldJava(pw, struct, defaults);
    }

    private void writeCtorParm(PrintWriter pw, ClassDefine struct) {
        struct.onOverflowDefault(LoadOverflowAction.Trunc);
        struct.onUnderflowDefault(LoadUnderflowAction.Pad);
        pw.printf("    private %s(String s) {%n", struct.getName());
        pw.printf("        super(s, LRECL, %b, %b);%n",
            struct.onOverflowThrowError(), struct.onUnderflowThrowError());
        closeBrace(pw);
        pw.printf("    private %s(FixRecord r) {%n", struct.getName());
        pw.printf("        super(r, LRECL, %b, %b);%n",
            struct.onOverflowThrowError(), struct.onUnderflowThrowError());
        closeBrace(pw);
        pw.printf("    private %s(char[] c) {%n", struct.getName());
        pw.printf("        super(c, LRECL, %b, %b);%n",
            struct.onOverflowThrowError(), struct.onUnderflowThrowError());
        closeBrace(pw);

        pw.printf("    public static %s of(FixRecord r) {%n", struct.getName());
        pw.printf("        return new %s(r);%n", struct.getName());
        closeBrace(pw);
        pw.printf("    public static %s decode(String s) {%n", struct.getName());
        pw.printf("        return new %s(s);%n", struct.getName());
        closeBrace(pw);
        pw.printf("    public %s copy() {%n", struct.getName());
        pw.printf("        return new %s(Arrays.copyOf(rawData, LRECL));%n", struct.getName());
        closeBrace(pw);
    }

    private void writeCtorVoid(PrintWriter pw, String name) {
        pw.printf("    public %s() {%n", name);
        pw.printf("        super(LRECL);%n");
        pw.printf("        initialize();%n");
        closeBrace(pw);
    }

    private void closeBrace(PrintWriter pw) {
        pw.printf("    }%n");
    }

    private void writeConstant(PrintWriter pw, ParentFields struct, int deep, boolean isRedefined) {
        if (deep == 0)
            pw.printf("    public static final int LRECL = %d;%n", struct.getLength());
        if (isRedefined || (struct instanceof FieldGroup && ((FieldGroup) struct).isRedefines())) {
            struct.getFields().forEach(it -> {
                if (it instanceof HaveConstants)
                    log.warn("Constant in REDEFINED field at {}+{} in group {}", it.getOffset(), it.getLength(), struct.getName());
                if (it instanceof ParentFields) writeConstant(pw, (ParentFields) it, deep + 1, true);
            });

        } else {
            struct.getFields().forEach(it -> {
                if (it instanceof HaveConstants)
                    ((HaveConstants) it).writeConstant((u, v) -> pw.printf("    private static final String %s = %s;%n", u, v));
                if (it instanceof ParentFields) writeConstant(pw, (ParentFields) it, deep + 1, false);
            });
        }
    }

    private void writeBeginClass(PrintWriter pw, ClassDefine struct) {
        pw.printf("public class %s extends FixRecord {%n", struct.getName());
    }

    private void writeImport(PrintWriter pw) {
        pw.printf("import java.util.Arrays;%n");
        pw.println();
    }

    private void writeImport(PrintWriter pw, String packg) {
        pw.printf("import %s.FieldValidateHandler;%n", packg);
        pw.printf("import %s.FixRecord;%n", packg);
        pw.printf("import %s.OverflowAction;%n", packg);
        pw.printf("import %s.UnderflowAction;%n", packg);
        pw.println();
    }

    private void writePackage(PrintWriter pw, String packg) {
        writeCopyright(pw);
        pw.printf("package %s;%n%n", packg);
    }

    private static class DumpAware {
        public final String name;
        public final int offset;
        public final int length;

        public DumpAware(String name, int offset, int length) {
            this.name = name;
            this.offset = offset;
            this.length = length;
        }

        public void dump(PrintWriter pw) {
            pw.printf("        sb.append(\"%s : \").append(dump(%d,%d)).append('\\n');%n", name, offset - 1, length);
        }
    }

    private static class DumpPicure extends DumpAware {
        public final String picture;

        public DumpPicure(String name, int offset, int length, String picture) {
            super(name, offset, length);
            this.picture = picture;
        }

        public DumpAware normalize() {
            return new DumpAware(name + ": " + picture + "(" + length + ")@" + offset, offset, length);
        }
    }
}